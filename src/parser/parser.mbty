%{
typealias @syntax.Name
typealias @concrete.Declaration
typealias @concrete.Expr
typealias @concrete.WhereClause
typealias @concrete.TypedBinding
typealias @concrete.UntypedBinding
typealias @concrete.Type
typealias @concrete.Telescope
typealias @util.Loc
typealias @util.Interval
typealias @util.Range
traitalias @util.HasRange
typealias @util.NonEmptyList as List1
typealias @util.Either
%}

%derive<Show> Token
%derive<Show> ParseError
%position<Loc>
%start file

%token Eof
%token Indent
%token Outdent
%token <Loc> Newline
%token <(Loc, String)> ErrorMsg

%token<(Interval, String)> Id
%token<(Interval, Int)> IntLiteral


%token<Interval> SymOpenParen       "("
%token<Interval> SymCloseParen      ")"
%token<Interval> SymOpenBrace       "{"
%token<Interval> SymCloseBrace      "}"
%token<Interval> SymColon           ":"
%token<Interval> SymLambda          "\\"
%token<Interval> SymEqual           "="
%token<Interval> SymArrow           "->"
%token<Interval> SymDot             "."
%token<Interval> SymUnderscore      "_"

%token<Interval> KwSet       "Set"
%token<Interval> KwMutual    "mutual"
%token<Interval> KwPostulate "postulate"
%token<Interval> KwData      "data"
%token<Interval> KwWhere     "where"
%token<Interval> KwNorm      "NORMALIZE"
%token<Interval> KwInfer     "INFER"
%token<Interval> KwCheck     "CHECK"



%type<Array[Declaration]> file
%type<Array[Declaration]> Declarations

%type<TypedBinding> TypedBinding
%type<UntypedBinding> UntypedBinding
%type<Telescope> Telescope

%type<Name> BId
%type<Expr> Expr
%type<Expr> Expr1
%type<Expr> Expr2
%type<Expr> Expr3
%type<List1[Expr]> Application
%type<List1[Expr]> Application3 

%type<Declaration> Declaration
%type<Declaration> FunDefOrTypeSig
%type<Declaration> DataDef
%type<Declaration> Mutual
%type<Declaration> Postulate
%type<Either[Expr, Type]> RHSOrTypeSig
%type<WhereClause> WhereClause
%type<Declaration> Cmd



%right SymArrow

%%



file
  : Declarations Eof                 { $1 }
  ;

Declarations
  :                                  { [] }
  | Declarations Declaration         { $1.push($2); $1 }
  ;

Declaration
  : Cmd                              { $1 }
  | FunDefOrTypeSig                  { $1 }
  | DataDef                          { $1 }
  | Mutual                           { $1 }
  | Postulate                        { $1 }
  ;

Cmd
  : KwCheck                          { Command(NoRange, CheckCtx) }
  | KwInfer BId                      { Command(NoRange, InferType($2)) }
  | KwNorm Expr                      { Command(NoRange, Normalize($2)) }
  ;


(* Top level, function types *)
Expr
  : TypedBinding "->" Expr           { Pi($1, $3) }
  | Expr1                            { $1 }


(* Level 1 : Application *)
Expr1
  : Application                      { raw_application($1) }
  | Application3                     { raw_application($1) }
  ;

(* applicaton without `with` *)
Application
  : Expr2                            { List1::singleton($1) }
  | Expr3 Application                { $2.cons($1) }
  ;


(* Level 2 : Lambda *)
Expr2
  : "\\" UntypedBinding Expr         { Lam($2, $3) }
  | Expr3                            { $1 }
  ;


(* Level 3 : Atoms *)
Expr3
  : "{" BId "=" Expr "}"             { HiddenArg(NoRange, Some($2), $4) }
  | "{" Expr "}"                     { HiddenArg(NoRange, None, $2) }
  | "_"                              { Hole(HasRange::get_range($1)) }
  | "." Expr3                        { Dot(NoRange, $2) }
  | BId                              { Ident($1) }
  | "Set" level=IntLiteral           { Set(Range::merge_range($1, level.0), level.1) }
  | "Set"                            { Set(HasRange::get_range($1), 0) }
  | "(" Expr ")"                     { $2 }
  ;

(* application within `with` *)
Application3
  : Expr3                            { List1.singleton($1) }
  | Expr3 Application3               { $2.cons($1) }


BId
  : Id                               { Name::new(HasRange::get_range($1.0), $1.1) }
  | "_"                              { Name::new(NoRange, "_") }
  ;

UntypedBinding
  :  BId  "."                        { UntypedBinding((NoRange, $1, NotHiding)) }
  | "{" BId "}" "."                  { UntypedBinding((NoRange, $2, Hiding)) }
  ;


TypedBinding
  : "(" BId ":" Expr ")"             { TypedBinding((NoRange, $2,  NotHiding, $4)) }
  | "{" BId ":" Expr "}"             { TypedBinding((NoRange, $2,  Hiding,    $4)) }
  | "(" Expr ")"                     { TypedBinding((NoRange, Name::new(NoRange, "_"), NotHiding, $2)) }
  | "{" Expr "}"                     { TypedBinding((NoRange, Name::new(NoRange, "_"), Hiding,    $2)) }
  | Expr                             { TypedBinding((NoRange, Name::new(NoRange, "_"), NotHiding, $1)) }
  ;

Telescope
  :  { [] }
  |  Telescope TypedBinding          { $1.push($2); $1 }
  ;



FunDefOrTypeSig
  :  Expr1 RHSOrTypeSig WhereClause  { funclause_or_typesig($1, $2, $3) }
  ;


RHSOrTypeSig
  : "=" Expr         { Left($2) }
  | ":" Expr         { Right($2) }
  ;

WhereClause
  :                                     { NoWhere }
  | "where" Indent Declarations Outdent { Where(HasRange::get_range($1), $3) }
  ;

DataDef
  : "data" BId Telescope ":" Expr "where" Indent Declarations Outdent { DataDef(HasRange::get_range($1), $2, $3, $5, $8) }
  ;

Mutual
  : "mutual" Indent Declarations Outdent  { Mutual(HasRange::get_range($1), $3) }
  ;

Postulate
  : "postulate" Indent Declarations Outdent { Postulate(HasRange::get_range($1), $3) }
  ;

