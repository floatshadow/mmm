%{

using @syntax {type Name}
using @concrete {type Declaration}
using @concrete {type Expr}
using @concrete {type WhereClause}
using @concrete {type TypedBinding}
using @concrete {type UntypedBinding}
using @concrete {type Type}
using @concrete {type Telescope}
using @util {type Loc}
using @util {type Interval}
using @util {type Range}
using @util {trait HasRange}
using @util {type List1}
using @util {type Either}

%}

%derive<Show> Token
%derive<Show> ParseError
%position<Loc>
%start parse_file

%token Eof
%token VOpen
%token VSemi
%token VClose
%token <(Loc, String)> ErrorMsg

%token<(Interval, String)> Identifier
%token<(Interval, Int)> IntLiteral


%token<Interval> SymOpenParen       "("
%token<Interval> SymCloseParen      ")"
%token<Interval> SymOpenBrace       "{"
%token<Interval> SymCloseBrace      "}"
%token<Interval> SymColon           ":"
%token<Interval> SymLambda          "\\"
%token<Interval> SymEqual           "="
%token<Interval> SymArrow           "->"
%token<Interval> SymDot             "."
%token<Interval> SymUnderscore      "_"

%token<Interval> KwSet       "Set"
%token<Interval> KwMutual    "mutual"
%token<Interval> KwPostulate "postulate"
%token<Interval> KwData      "data"
%token<Interval> KwWhere     "where"
%token<Interval> KwNorm      "NORMALIZE"
%token<Interval> KwInfer     "INFER"
%token<Interval> KwCheck     "CHECK"



%type<Array[Declaration]> parse_file
%type<Array[Declaration]> TopDeclarations
%type<List1[Declaration]> Declarations
%type<Array[Declaration]> Declarations0
%type<List1[Declaration]> Declarations1

%type<TypedBinding> TypedBinding
%type<UntypedBinding> UntypedBinding
%type<Telescope> Telescope

%type<Name> Id
%type<Name> BId
%type<Expr> Expr
%type<Expr> Expr1
%type<Expr> Expr2
%type<Expr> Expr3
%type<List1[Expr]> Application
%type<List1[Expr]> Application3 

%type<Declaration> Declaration
%type<Declaration> FunDefOrTypeSig
%type<Declaration> DataDef
%type<Declaration> Mutual
%type<Declaration> Postulate
%type<Either[Expr, Type]> RHSOrTypeSig
%type<WhereClause> WhereClause
%type<Declaration> Cmd


%right "->" 

%%



parse_file
  : VSemi TopDeclarations Eof  { $2 }
  ;

(* top level: Arbitrary declarations *)
Declarations
  : VOpen Declarations1 VClose       { $2 }
  ;

Declarations0
  : VOpen VClose                     { [] }
  | Declarations                     { $1.to_array() }
  ;


Declarations1
  : Declaration VSemi Declarations1  { $3.cons($1) }
  | Declaration                      { List1::singleton($1) }
  ;

(* Top level declarations *)
TopDeclarations
  :                                  { [] }
  | Declarations1                    { $1.to_array() }
  ;

(* declarations or commands *)
Declaration
  : Cmd                              { $1 }
  | FunDefOrTypeSig                  { $1 }
  | DataDef                          { $1 }
  | Mutual                           { $1 }
  | Postulate                        { $1 }
  ;

Cmd
  : KwCheck                          { Command(NoRange, CheckCtx) }
  | KwInfer BId                      { Command(NoRange, InferType($2)) }
  | KwNorm Expr                      { Command(NoRange, Normalize($2)) }
  ;


Id
  : Identifier                       { Name::new(HasRange::get_range($1.0), $1.1) }
  ;

(* BId is an identifier that can be used as a binding *)
BId
  : Id                               { $1 }
  | "_"                              { Name::new(HasRange::get_range($1), "_") }
  ;

(* Top level, function types *)
Expr
  : TypedBinding "->" Expr           { Pi($1, $3) }
  | Application3 "->" Expr           { Pi(TypedBinding(HasRange::get_range($1), Name::new(NoRange, "_"), NotHiding, raw_application($1)), $3) }
  | Expr1                            { $1 }
  ;


(* Level 1 : Application *)
Expr1
  : Application                      { raw_application($1) }
  | Application3                     { raw_application($1) }
  ;

(* applicaton without `with` *)
Application
  : Expr2                            { List1::singleton($1) }
  | Expr3 Application                { $2.cons($1) }
  ;


(* Level 2 : Lambda *)
Expr2
  : "\\" UntypedBinding Expr         { Lam($2, $3) }
  | Expr3                            { $1 }
  ;


(* Level 3 : Atoms *)
Expr3
  : "{" BId "=" Expr "}"             { HiddenArg(Range::merge_range5($1, $2, $3, $4, $5), Some($2), $4) }
  | "{" Expr "}"                     { HiddenArg(Range::merge_range3($1, $2, $3), None, $2) }
  | "_"                              { Hole(HasRange::get_range($1)) }
  | "." Expr3                        { Dot(Range::merge_range($1, $2), $2) }
  | Id                               { Ident($1) }
  | "Set" level=IntLiteral           { Set(Range::merge_range($1, level.0), level.1) }
  | "Set"                            { Set(HasRange::get_range($1), 0) }
  | "(" Expr ")"                     { $2 }
  ;

(* application within `with` *)
Application3
  : Expr3                            { List1::singleton($1) }
  | Expr3 Application3               { $2.cons($1) }


UntypedBinding
  :  BId  "."                        { UntypedBinding(HasRange::get_range($1), $1, NotHiding) }
  | "{" BId "}" "."                  { UntypedBinding(Range::merge_range3($1, $2, $3), $2, Hiding) }
  ;


TypedBinding
  : "(" BId ":" Expr ")"             { TypedBinding(Range::merge_range5($1, $2, $3, $4, $5), $2,  NotHiding, $4) }
  | "{" BId ":" Expr "}"             { TypedBinding(Range::merge_range5($1, $2, $3, $4, $5), $2,  Hiding,    $4) }
  | "(" Expr ")"                     { TypedBinding(Range::merge_range3($1, $2, $3), Name::new(NoRange, "_"), NotHiding, $2) }
  | "{" Expr "}"                     { TypedBinding(Range::merge_range3($1, $2, $3), Name::new(NoRange, "_"), Hiding,    $2) }
  ;

Telescope
  :  { [] }
  |  Telescope TypedBinding          { $1.push($2); $1 }
  ;



FunDefOrTypeSig
  :  Expr1 RHSOrTypeSig WhereClause  { funclause_or_typesig($1, $2, $3) }
  ;


RHSOrTypeSig
  : "=" Expr         { Left($2) }
  | ":" Expr         { Right($2) }
  ;

WhereClause
  :                               { NoWhere }
  | "where" Declarations0         { Where(HasRange::get_range($1), $2) }
  ;

DataDef
  : "data" BId Telescope ":" Expr "where" Declarations0 { DataDef(HasRange::get_range($1), $2, $3, $5, $7) }
  ;

Mutual
  : "mutual" Declarations0  { Mutual(HasRange::get_range($1), $2) }
  ;

Postulate
  : "postulate" Declarations0 { Postulate(HasRange::get_range($1), $2) }
  ;

